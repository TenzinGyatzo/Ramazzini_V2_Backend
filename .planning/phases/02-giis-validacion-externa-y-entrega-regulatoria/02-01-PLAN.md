---
wave: 1
depends_on: []
files_modified:
  - src/modules/giis-export/validation/giis-validation.service.ts
  - src/modules/giis-export/validation/validation.types.ts
  - src/modules/giis-export/validation/schema-based-validator.ts
  - src/modules/giis-export/giis-batch.service.ts
  - src/modules/giis-export/giis-export.module.ts
  - src/modules/giis-export/giis-export.controller.ts
  - test/nom024/giis-validation.nom024.spec.ts
autonomous: true
---

# Plan 02-01 — Subfase 2A: Validación profunda por campo

**Objetivo:** Implementar validación profunda por campo (reglas del diccionario/schema), modo pre-validación (solo reporte, sin generar TXT), modo generación con skip-row y Reporte de Excluidos (estructura guía/renglón/campo/causa). Clasificación bloqueantes vs advertencias y estado "validated". Alineado con CONTEXT.md y 02-RESEARCH.md.

**Fuente de reglas:** En `backend/docs/nom-024/giis_schemas/` (CDT, CEX, LES) cada campo tiene **validationRaw** (texto en español con la regla normativa) y metadatos estructurados (requiredColumn, type.maxLength). Esas reglas en texto deben **convertirse en lógica ejecutable**: el validador debe implementar el equivalente en código de lo que describe cada validationRaw (obligatorio, longitud, catálogo, formato, rangos, reglas cruzadas, etc.). No basta con validar solo required + maxLength; hay que traducir las reglas expresadas en validationRaw a código (por tipo de regla: catálogos, formato fecha, caracteres permitidos, validación CURP, edad, etc.), usando validationRaw como especificación y los metadatos del schema donde existan.

**Restricciones:** No reescribir Phase 1; extender con GiisValidationService. Encoding Windows-1252 se preserva en el pipeline existente; la validación actúa sobre datos antes de serializar.

---

## must_haves

- [ ] **GiisValidationService** con: (1) `preValidate(periodo, guía(s), clues)` que no escribe TXT y devuelve lista de errores/advertencias por registro con estructura `{ guide, rowIndex, field, cause, severity: 'blocker'|'warning' }`. (2) Integración en flujo de generación: por cada fila candidata, validar; si hay bloqueante, skip row y acumular en "Reporte de Excluidos"; si solo warnings, incluir fila y opcionalmente acumular warning para confirmación posterior.
- [ ] **Reglas: convertir validationRaw en lógica real.** Los schemas CDT/CEX/LES tienen por cada campo un texto `validationRaw` (regla en español). Esa especificación debe traducirse a lógica ejecutable: (a) usar metadatos estructurados del schema (requiredColumn, type.maxLength, type.kind) para required y longitud; (b) implementar por tipo de regla: valores en catálogo (CatalogsService), formato fecha dd/mm/aaaa y rangos de fecha/edad, caracteres permitidos (A–Z, Ñ, caracteres especiales permitidos), validación CURP (formato/genérico), reglas cruzadas (ej. si CURP genérico omitir validación de nombre/apellidos). Clasificación: **bloqueantes** = obligatorio faltante, fuera de catálogo, estructura/formato inválido; **warnings** = reglas de negocio suaves. No hand-roll catálogos; reutilizar existentes. validationRaw es la fuente de verdad para qué validar; la implementación es código que cumple esa especificación.
- [ ] Batch/artifacts: estado explícito de validación (ej. `validationStatus: 'validated' | 'has_warnings' | 'has_blockers'`) y metadatos del reporte de excluidos (cantidad de filas omitidas, resumen). El paso a cifrado (2B) solo se habilita si no hay bloqueantes; con warnings se requiere confirmación del usuario.
- [ ] **Reporte de Excluidos:** estructura guía, renglón (índice o folio), campo, causa. Salida: (1) para API: JSON/array para grid; (2) para descarga: CSV (encoding UTF-8 o Windows-1252 según consumo). Roles: visible para Principal, Administrador o encargado de estadística (validación de permisos en controller).
- [ ] Tests: unit para validador (bloqueante vs warning, skip row), integración que pre-valida sin generar TXT y que genera con skip row y obtiene Reporte de Excluidos; test que verifica que con bloqueantes no se marca "validated" para cifrado.

---

## Tasks

<task>
**Task 2A.1 — Tipos y validador basado en schema**
- Crear `src/modules/giis-export/validation/validation.types.ts`: interfaces para `ValidationError` (guide, rowIndex, field, cause, severity), `PreValidationResult`, `ExcludedRowReport`, y tipo para severity `'blocker'|'warning'`.
- Crear `src/modules/giis-export/validation/schema-based-validator.ts`: función(es) que reciban un schema (CDT/CEX/LES) y una fila (Record) y devuelvan lista de ValidationError. Implementar lógica que refleje lo descrito en **validationRaw** de cada campo: required y maxLength desde schema; para reglas que solo están en texto (formato fecha, caracteres permitidos, CURP, catálogos, rangos de edad, reglas cruzadas), implementar validadores por tipo (ej. por nombre de campo o por patrón en validationRaw) de forma que el comportamiento sea equivalente a la especificación en validationRaw. Usar CatalogsService para catálogos; no modificar los JSON de schema, solo leerlos con loadGiisSchema. Marcar cada error como blocker o warning según CONTEXT. Tests unitarios con fixtures de fila válida e inválida (incluir casos que ejerciten reglas derivadas de validationRaw, no solo required/maxLength).
</task>

<task>
**Task 2A.2 — GiisValidationService y flujo pre-validación / generación con skip row**
- Crear `src/modules/giis-export/validation/giis-validation.service.ts`. Método `preValidate(proveedorSaludId, yearMonth, guides: ('CDT'|'CEX'|'LES')[], establecimientoClues)`: obtiene datos del periodo (reutilizar lógica de GiisBatchService para obtener detecciones/notas/lesiones según guía), por cada guía mapea a filas (reutilizar mappers existentes), ejecuta schema-based-validator por fila, devuelve lista agregada de errores/warnings sin escribir TXT.
- Método `validateAndFilterRows(guide, rows, schema)`: por cada fila, validar; si tiene al menos un blocker, excluir fila y añadir a excludedReport; si solo warnings, incluir fila y opcionalmente añadir warnings a lista. Devolver `{ validRows, excludedReport, warnings }`.
- Integrar en GiisBatchService: en generateBatchCdt/Cex/Les, antes de serializar, llamar a validateAndFilterRows; usar validRows para el TXT y guardar excludedReport en el batch (artifacts o campo dedicado). Añadir validationStatus al batch (validated / has_warnings / has_blockers) según resultado.
- Registrar GiisValidationService en giis-export.module.ts (providers). Tests: preValidate no escribe archivos; generate con datos que tienen errores bloqueantes produce menos filas y Reporte de Excluidos poblado.
</task>

<task>
**Task 2A.3 — API pre-validación, Reporte de Excluidos (grid + CSV) y tests**
- En GiisExportController: endpoint `POST /giis-export/prevalidate` (body: yearMonth, guides[], opcional establecimientoClues desde usuario) que llama a GiisValidationService.preValidate y devuelve lista de errores/warnings para grid. Endpoint `GET /giis-export/batches/:batchId/excluded-report` que devuelve Reporte de Excluidos en JSON (para grid) y opción `?format=csv` para descarga CSV. Proteger con roles Principal/Administrador (o encargado estadística) según CONTEXT.
- Asegurar que validationStatus esté disponible en `GET /giis-export/batches/:batchId` para que el cliente sepa si puede habilitar cifrado (solo si no has_blockers). Tests API: prevalidate retorna 200 y lista; excluded-report retorna CSV con columnas guía, renglón, campo, causa; test que con batch que tiene bloqueantes validationStatus es has_blockers.
</task>

---

## Verification

- `npm run test:nom024` incluye specs de validación y pasa.
- Pre-validación no genera archivos TXT en disco.
- Generación con filas inválidas produce TXT con solo filas válidas y Reporte de Excluidos coherente.
- validationStatus bloquea lógicamente el paso a cifrado (2B) cuando hay bloqueantes (verificado en test o integración).

---

## Checkpoints

- Ninguno bloqueante para 2A; si se detecta que un catálogo necesario no está expuesto en CatalogsService, documentar y usar conjunto estático desde schema o archivo de catálogo mínimo.
