---
wave: 3
depends_on: [04-02]
files_modified:
  - src/modules/audit/audit.service.ts
  - src/modules/audit/audit.module.ts
  - src/modules/auth/auth.service.ts
  - src/modules/expedientes/expedientes.service.ts
  - src/modules/giis-export/giis-batch.service.ts
  - src/modules/giis-export/giis-export.controller.ts
  - src/modules/users/users.service.ts
  - src/modules/audit/constants/audit-event-class.ts
autonomous: false
---

# Plan 04-03 — Capa 3: Instrumentación de auditoría (hooks en flujos existentes)

**Objetivo:** Implementar AuditService.record() con hash canónico y cadena; política Clase 1 (hard-fail) vs Clase 2 (soft-fail con audit_outbox + alerta). Conectar llamadas a record() en: auth (login success/fail), expedientes (crear borrador, actualizar borrador, finalizar, crear corrección, anular), usuarios (roles/permisos), GIIS (export iniciado, generado por archivo, descargado, validación). AuditEvent es fuente unificada; GiisExportAudit se mantiene como detalle y se escribe con proveedorSaludId.

**Puntos críticos:** Clase 1: si record() lanza, la operación que lo invocó debe fallar (no capturar excepción). Clase 2: si record() falla, escribir en audit_outbox y registrar alerta (log o servicio de alertas); no fallar la operación del usuario.

---

## must_haves

- [ ] **AuditService.record():** Obtener último evento del proveedor (por timestamp desc) para hashEventoAnterior; construir payload canónico; calcular hashEvento con canonical-hash.util; insertar en AuditEvent (insert único, sin update). Si eventClass === CLASS_1_HARD_FAIL y el insert falla, relanzar la excepción. Si eventClass === CLASS_2_SOFT_FAIL y el insert falla, escribir en audit_outbox (payload serializado, eventClass, errorMessage) y log/alert; no lanzar.
- [ ] **Auth:** Tras login exitoso, llamar auditService.record(proveedorSaludId, userId, LOGIN_SUCCESS, ..., CLASS_2_SOFT_FAIL). Tras login fallido (credenciales inválidas), record(proveedorSaludId o null si no hay proveedor, actor identificado por IP o "anonymous", LOGIN_FAIL, ..., CLASS_2_SOFT_FAIL). Obtener proveedorSaludId del usuario si existe; si no hay usuario (fail), usar contexto request o null y documentar.
- [ ] **Expedientes (NOM-024):** Crear borrador: record DOC_CREATE_DRAFT (Clase 2). Actualizar borrador: record DOC_UPDATE_DRAFT (Clase 2). Finalizar documento: record DOC_FINALIZE, CLASS_1_HARD_FAIL — llamar a record antes de confirmar finalización; si falla, no finalizar. Crear corrección/nueva versión: guardar snapshot en document_versions, luego record DOC_CREATE_CORRECTION, CLASS_1_HARD_FAIL. Anular: record DOC_ANULATE, CLASS_1_HARD_FAIL. En todos los casos proveedorSaludId y actorId del request.
- [ ] **Resguardado (D3):** Mantener/bloquear PATCH/PUT sobre documento FINALIZADO en proveedor NOM-024 (ya existe en expedientes.service). Nueva lógica: corrección = crear entrada en document_versions (snapshot completo) + AuditEvent DOC_CREATE_CORRECTION. No edición in-place del documento finalizado.
- [ ] **Users (admin):** Cambios de roles/permisos: record ADMIN_ROLES_PERMISSIONS, CLASS_1_HARD_FAIL. Obtener proveedorSaludId del usuario afectado o del contexto. Cambios de configuración SIRES relevantes: record ADMIN_CONFIG_SIRES, CLASS_1_HARD_FAIL.
- [ ] **GIIS:** En createBatch o inicio de generación: record GIIS_EXPORT_STARTED (actor = usuario o SYSTEM), CLASS_1_HARD_FAIL; incluir proveedorSaludId del proveedor. Por cada archivo generado (CDT/CEX/LES): seguir escribiendo GiisExportAudit (con proveedorSaludId) y además record AuditEvent GIIS_EXPORT_FILE_GENERATED, CLASS_1_HARD_FAIL. En descarga (controller download): record GIIS_EXPORT_DOWNLOADED (lectura sensible D1), CLASS_1_HARD_FAIL. Tras validación batch: record GIIS_VALIDATION_EXECUTED, CLASS_1_HARD_FAIL. Siempre proveedorSaludId del proveedor SIRES.
- [ ] **Audit export (lectura sensible):** En el endpoint de export del audit trail (plan 04-05), al generar y devolver el archivo: record AUDIT_EXPORT_DOWNLOAD con actor y proveedorSaludId, CLASS_1_HARD_FAIL (o Clase 2 según criterio; CONTEXT dice descarga audit = sensible).
- [ ] **Actor SYSTEM:** Cuando el actor es un job (ej. export programado), actorId puede ser string "SYSTEM" o ObjectId de cuenta de servicio; documentar en constantes.

---

## Tasks

<task>
**Task 04-03.1 — Implementar AuditService.record()**
- Inyectar modelo AuditEvent, AuditOutbox y usar canonical-hash.util. En record(): 1) Resolver último evento del proveedor (findOne sort timestamp desc) para hashEventoAnterior. 2) Construir objeto canónico (proveedorSaludId, actorId, timestamp new Date(), actionType, resourceType, resourceId, payload). 3) computeCanonicalHash(canonical, previousHash). 4) Insert AuditEvent con hashEvento y hashEventoAnterior. Si eventClass === CLASS_1 y insert falla, throw. Si eventClass === CLASS_2 y insert falla, insert en AuditOutbox con errorMessage y log.warn/alert; return.
- Registrar AuditService en AuditModule y exportarlo. Probar unitariamente con mock de modelo (Clase 1 lanza, Clase 2 escribe outbox).
</task>

<task>
**Task 04-03.2 — Hooks en Auth**
- En auth.service (login): tras validar credenciales y generar token, obtener proveedorSaludId del user. Llamar auditService.record({ proveedorSaludId, actorId: user._id, actionType: LOGIN_SUCCESS, eventClass: CLASS_2_SOFT_FAIL }). En flujo de login fallido (credenciales incorrectas), llamar record con actionType LOGIN_FAIL; actorId puede ser null o identificador de intento (IP/id); proveedorSaludId null si no hay sesión. No bloquear respuesta al usuario si record falla (Clase 2).
</task>

<task>
**Task 04-03.3 — Hooks en Expedientes (finalizar, corrección, anular)**
- En expedientes.service: antes de finalizar documento (finalizarDocumento), llamar auditService.record(DOC_FINALIZE, resourceType: documentType, resourceId: id, proveedorSaludId, actorId, CLASS_1_HARD_FAIL). Si record lanza, no ejecutar finalización. Tras anular: record DOC_ANULATE igual, CLASS_1_HARD_FAIL. Para "crear corrección": guardar snapshot en document_versions (nueva versión), luego record DOC_CREATE_CORRECTION con resourceId y opcionalmente versionId, CLASS_1_HARD_FAIL. Crear borrador y actualizar borrador: record DOC_CREATE_DRAFT / DOC_UPDATE_DRAFT, CLASS_2_SOFT_FAIL. Asegurar que bloqueo de PATCH sobre FINALIZADO (NOM-024) siga activo; corrección solo vía nuevo documento/versión.
</task>

<task>
**Task 04-03.4 — Hooks en Users (roles/permisos)**
- En users.service (update de roles o permisos): tras aplicar cambios, auditService.record(ADMIN_ROLES_PERMISSIONS, resourceType: 'user', resourceId: userId, proveedorSaludId, actorId del request, CLASS_1_HARD_FAIL). Si no hay proveedorSaludId en el usuario, usar el del contexto. Config SIRES: si existe endpoint o servicio de configuración SIRES, record ADMIN_CONFIG_SIRES en los puntos relevantes, CLASS_1_HARD_FAIL.
</task>

<task>
**Task 04-03.5 — Hooks en GIIS (export iniciado, por archivo, descargado, validación)**
- En giis-batch.service: al crear o iniciar batch, obtener proveedorSaludId. record(GIIS_EXPORT_STARTED, batchId como resourceId, proveedorSaludId, actorId o SYSTEM, CLASS_1_HARD_FAIL). Donde ya se llama a GiisExportAudit.recordGenerationAudit, añadir proveedorSaludId al payload de GiisExportAudit y además auditService.record(GIIS_EXPORT_FILE_GENERATED, ...). En controller de download (GET batches/:id/download/:guide): tras servir archivo, record(GIIS_EXPORT_DOWNLOADED, ...). Tras ejecutar validación (validateBatch o similar), record(GIIS_VALIDATION_EXECUTED). Todos Clase 1 para GIIS según D8.
</task>

<task>
**Task 04-03.6 — Registrar AuditService en módulos que lo usan**
- AuditModule exporta AuditService. AuthModule, ExpedientesModule, GiisExportModule, UsersModule importan AuditModule y inyectan AuditService donde corresponda. Evitar dependencias circulares (si audit depende de expedientes para document_versions, considerar que document_versions viva en expedientes y audit solo lea vía API o evento).
</task>

---

## Verification

**Estado document_versions:** La parte de schema document_versions / DocumentVersion y endpoints de versiones fue removida. El resguardado se cumple con documentos inalterables y Notas Aclaratorias.

- Finalizar documento en proveedor NOM-024: si se desactiva temporalmente la BD de audit, la finalización debe fallar (Clase 1).
- Login fallido: si audit falla, el login fallido sigue respondiendo y el evento queda en audit_outbox (Clase 2).
- Export GIIS: al menos un evento AuditEvent por batch (iniciado + por archivo + descargado + validación). GiisExportAudit sigue teniendo registros con proveedorSaludId.
- No updates destructivos sobre documentos FINALIZADO (NOM-024): rechazo 403/409 y corrección solo vía nueva versión.

---

## Criterios de aceptación NOM-024 (este plan)

- Toda acción crítica (finalizar, corrección, anular, export GIIS, roles) tiene actor único y evento append-only; fallo de audit implica fallo de operación (D8 Clase 1).
- Eventos auxiliares (login fail) tienen fallback a outbox + alerta (D8 Clase 2).
- Cobertura D7: accesos, docs, admin, sistema, GIIS; AuditEvent fuente unificada; GiisExportAudit con proveedorSaludId.
