---
wave: 1
depends_on: []
files_modified:
  - src/modules/audit/audit.module.ts
  - src/modules/audit/constants/audit-action-type.ts
  - src/modules/audit/constants/audit-event-class.ts
  - src/modules/audit/interfaces/audit-event-canonical.interface.ts
  - src/modules/audit/interfaces/audit-service.interface.ts
  - src/modules/audit/utils/canonical-hash.util.ts
  - src/modules/audit/spec/canonical-json.spec.md
autonomous: true
---

# Plan 04-01 — Capa 1: Preparación y cimientos (modelos, enums, contratos)

**Objetivo:** Establecer los contratos, enums y utilidades de hash canónico para el Audit Trail sin tocar persistencia. Base para todos los planes siguientes. Referencia única: CONTEXT.md Phase 4 (decisiones D1–D8 bloqueadas).

**Alcance:** Solo definiciones y utilidades. No se crean colecciones ni se instrumentan flujos.

---

## must_haves

- [ ] **Enum AuditActionType** (checklist D7): `DOC_CREATE_DRAFT`, `DOC_UPDATE_DRAFT`, `DOC_FINALIZE`, `DOC_CREATE_CORRECTION`, `DOC_ANULATE`, `LOGIN_SUCCESS`, `LOGIN_FAIL`, `ADMIN_ROLES_PERMISSIONS`, `ADMIN_CONFIG_SIRES`, `SYSTEM_JOB`, `GIIS_EXPORT_STARTED`, `GIIS_EXPORT_FILE_GENERATED`, `GIIS_EXPORT_DOWNLOADED`, `GIIS_VALIDATION_EXECUTED`, `AUDIT_EXPORT_DOWNLOAD`. Extensible (nuevos valores sin romper consultas).
- [ ] **Enum AuditEventClass:** `CLASS_1_HARD_FAIL`, `CLASS_2_SOFT_FAIL`. Usado por AuditService para decidir si fallo de escritura propaga (Clase 1) o va a outbox + alerta (Clase 2).
- [ ] **Interfaz de payload canónico** para cálculo de hash (D4): campos en orden fijo; timestamps ISO 8601 UTC; `null` explícito; sin campos derivados (`_id`, `hashEvento`). Documentar en `canonical-json.spec.md` el orden de llaves y reglas (ej. fechas siempre `toISOString()`).
- [ ] **Utilidad canonical-hash:** función que recibe objeto evento (proveedorSaludId, actorId, timestamp, actionType, resourceType, resourceId, payload, etc.) y devuelve `{ hashEvento: string, hashEventoAnterior?: string }` usando SHA-256 del JSON canónico. Opcional: segundo parámetro `previousEventHash` para cadena ligera.
- [ ] **Contrato IAuditService:** método `record(params: RecordAuditParams): Promise<void>`. Params: proveedorSaludId, actorId, actionType, resourceType?, resourceId?, payload?, eventClass (Clase 1 o 2). Sin implementación de persistencia en este plan; solo interfaz e inyección en módulo.
- [ ] **Módulo audit:** crear `src/modules/audit/` con audit.module.ts que exporte constantes, interfaces y util (no provider de persistencia aún).

---

## Tasks

<task>
**Task 04-01.1 — Enums y constantes**
- Crear `src/modules/audit/constants/audit-action-type.ts`: enum o const de strings para todos los actionType del checklist D7 (docs, accesos, admin, sistema, GIIS, audit export). Exportar tipo TypeScript para uso en servicios y schema.
- Crear `src/modules/audit/constants/audit-event-class.ts`: `CLASS_1_HARD_FAIL`, `CLASS_2_SOFT_FAIL` y mapeo actionType → class (documentar: finalizar, corrección, anular, export GIIS, roles/permisos = Clase 1; login fail y auxiliares = Clase 2).
</task>

<task>
**Task 04-01.2 — Interfaz de payload canónico y spec**
- Crear `src/modules/audit/interfaces/audit-event-canonical.interface.ts`: interfaz con campos que participan en el hash, en orden definido (proveedorSaludId, actorId, timestamp, actionType, resourceType, resourceId, payload, etc.). Timestamps como string ISO 8601 UTC; ausencias como `null`.
- Crear `src/modules/audit/spec/canonical-json.spec.md`: documento que define (1) orden exacto de llaves del JSON canónico, (2) formato de fechas (ISO 8601 UTC), (3) tratamiento de null/undefined, (4) exclusión de _id y hashEvento/hashEventoAnterior del payload a hashear. Referencia para implementación y auditoría.
</task>

<task>
**Task 04-01.3 — Utilidad de hash canónico**
- Crear `src/modules/audit/utils/canonical-hash.util.ts`: función `computeCanonicalHash(event: AuditEventCanonicalPayload, previousEventHash?: string | null): { hashEvento: string; hashEventoAnterior: string | null }`. Serializar evento a JSON canónico (orden de llaves según spec), SHA-256 hex; si se pasa previousEventHash, asignar a hashEventoAnterior. Sin dependencias de Mongoose ni Nest.
- Tests unitarios: mismo payload produce mismo hash; distinto orden de llaves (si se usara objeto genérico) produciría distinto hash; con previousEventHash el resultado incluye hashEventoAnterior.
</task>

<task>
**Task 04-01.4 — Contrato IAuditService y módulo**
- Crear `src/modules/audit/interfaces/audit-service.interface.ts`: interfaz con `record(params: RecordAuditParams): Promise<void>`. RecordAuditParams: proveedorSaludId, actorId, actionType, resourceType?, resourceId?, payload?, eventClass. No incluir implementación en este plan.
- Crear `src/modules/audit/audit.module.ts`: módulo NestJS que importe/exporte constantes e interfaces (y opcionalmente el util como provider si se inyecta). Sin MongooseModule ni AuditService real aún.
</task>

---

## Verification

- Build del backend pasa. Tests unitarios de canonical-hash pasan.
- Orden de llaves y reglas de JSON canónico quedan documentados en canonical-json.spec.md.
- Ninguna colección ni escritura a BD en este plan.

---

## Criterios de aceptación NOM-024 (este plan)

- Contrato y spec de hash canónico permiten verificación externa (tamper-evident) según D4.
- Clasificación Clase 1/2 definida y documentada para uso en instrumentación (D8).
