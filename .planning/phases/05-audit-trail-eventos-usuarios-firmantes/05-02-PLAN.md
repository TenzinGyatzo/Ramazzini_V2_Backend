---
wave: 2
depends_on: [05-01]
files_modified:
  - src/modules/users/users.controller.ts
  - src/modules/users/users.service.ts
autonomous: false
---

# Plan 05-02 — Instrumentación de eventos de usuarios en el Audit Trail

**Objetivo:** Llamar a `AuditService.record()` en todos los puntos donde la app crea, activa, suspende, reactiva, elimina usuarios o donde el usuario cambia su propia contraseña. Payload con datos no sensibles (email, nombre, rol); nunca contraseña ni hash. Clase 1 (hard-fail) en todos los casos.

**Contexto (05-CONTEXT.md):** Dos eventos por creación: invitación enviada (al registrar/enviar invitación) y usuario activado (al verificar cuenta). Suspensión y reactivación como USER_SUSPENDED y USER_REACTIVATED. Eliminación hard delete: un evento USER_DELETED. Cambio de contraseña solo cuando el usuario cambia la suya (flujo forgot-password/:token). Actor y proveedorSaludId según request o usuario afectado.

---

## must_haves

- [ ] **Register (invitación/creación):** Tras `usersService.register()` y envío de email de verificación, registrar evento `USER_INVITATION_SENT`. resourceId = user._id, resourceType = 'USER'. Payload: { email, username, role } (sin password). proveedorSaludId: del usuario creado si tiene idProveedorSalud; si no, null. actorId: si el registro es por un admin (endpoint protegido con JWT), usar getUserIdFromRequest(req); si es registro público, actorId = user._id (autoregistro).
- [ ] **Verify account (activación):** Tras activar cuenta en `verifyAccount` (verify/:token), registrar `USER_ACTIVATED`. resourceId = user._id, resourceType = 'USER'. Payload: { email, username, role }. proveedorSaludId del user si existe; actorId = user._id (el usuario que se activa).
- [ ] **Toggle cuenta (suspender/reactivar):** Tras `usersService.toggleAccountStatus()` en PATCH estado-cuenta/:userId, registrar `USER_SUSPENDED` si body.cuentaActiva === false, o `USER_REACTIVATED` si body.cuentaActiva === true. resourceId = userId (afectado), resourceType = 'USER'. Payload: datos no sensibles del usuario afectado (email, username, role). actorId = getUserIdFromRequest(req), proveedorSaludId del actor (usersService.getIdProveedorSaludByUserId(actorId)). eventClass CLASS_1_HARD_FAIL.
- [ ] **Eliminación:** En DELETE delete-user/:email, antes de borrar: obtener usuario por email para tener _id y snapshot (username, email, role). Tras `usersService.removeUserByEmail(email)`, registrar `USER_DELETED`. resourceId = user._id (el eliminado), resourceType = 'USER'. Payload: { email, username, role } del usuario eliminado. actorId y proveedorSaludId del request (admin que ejecuta). CLASS_1_HARD_FAIL.
- [ ] **Cambio de contraseña (forgot-password/:token):** Tras actualizar contraseña en POST forgot-password/:token (updatePassword), registrar `USER_PASSWORD_CHANGED`. resourceId = user._id, resourceType = 'USER'. Payload: sin datos sensibles (ej. solo { userId: user._id } o omitir datos de contraseña). actorId = user._id (el usuario cambia la suya). proveedorSaludId = user.idProveedorSalud si existe. CLASS_1_HARD_FAIL.
- [ ] **Actor snapshot:** Donde se disponga de usuario autenticado, usar usersService.getAuditActorSnapshot(actorId) y pasar actorSnapshot en record (el servicio de audit ya lo acepta si está en el contrato; si no, al menos actorId). Para register/verify/delete/password el payload del evento lleva los datos del recurso (usuario afectado); el actorSnapshot es opcional para la API actual.

---

## Tasks

<task>
**Task 05-02.1 — Register: USER_INVITATION_SENT**
- En users.controller.ts método register(): después de `this.usersService.register(createUserDto)` y `this.emailsService.sendEmailVerification(...)`, obtener proveedorSaludId (del user creado: user.idProveedorSalud) y actorId. Si el endpoint está protegido por guard que inyecta usuario, actorId = getUserIdFromRequest(req); si register es público, actorId = user._id.toString(). Llamar auditService.record({ proveedorSaludId: user.idProveedorSalud?.toString() ?? null, actorId, actionType: AuditActionType.USER_INVITATION_SENT, resourceType: 'USER', resourceId: user._id.toString(), payload: { email: user.email, username: user.username, role: user.role ?? null }, eventClass: AuditEventClass.CLASS_1_HARD_FAIL }). No incluir password ni token en payload.
</task>

<task>
**Task 05-02.2 — Verify account: USER_ACTIVATED**
- En users.controller.ts método verifyAccount(): después de confirmar la cuenta (user.verified = true, user.token = '', await user.save()), llamar auditService.record(USER_ACTIVATED, resourceType: 'USER', resourceId: user._id, payload: { email, username, role } del user, proveedorSaludId: user.idProveedorSalud ?? null, actorId: user._id.toString(), eventClass: CLASS_1_HARD_FAIL). Obtener username/role con user ya actualizado (select si hace falta).
</task>

<task>
**Task 05-02.3 — Toggle status: USER_SUSPENDED / USER_REACTIVATED**
- En users.controller.ts método toggleAccountStatus(): después de usersService.toggleAccountStatus(userId, body.cuentaActiva) y comprobar que user existe, obtener actorId = getUserIdFromRequest(req) y actorProveedorSaludId = await usersService.getIdProveedorSaludByUserId(actorId). Obtener snapshot del usuario afectado (email, username, role) para el payload. Llamar auditService.record con actionType = body.cuentaActiva ? USER_REACTIVATED : USER_SUSPENDED, resourceType: 'USER', resourceId: userId, payload: { email, username, role } del usuario afectado, proveedorSaludId: actorProveedorSaludId, actorId, eventClass: CLASS_1_HARD_FAIL. Si el controller no tiene acceso a req, añadir @Req() req y usarlo.
</task>

<task>
**Task 05-02.4 — Delete user: USER_DELETED**
- En users.controller.ts método removeUserByEmail(): antes de llamar a removeUserByEmail, hacer findOne por email para obtener el usuario (con select 'username email role _id idProveedorSalud'). Si no existe, responder 404 y no grabar evento. Después de removeUserByEmail(email), llamar auditService.record(USER_DELETED, resourceType: 'USER', resourceId: user._id.toString(), payload: { email: user.email, username: user.username, role: user.role ?? null }, proveedorSaludId e actorId del admin que ejecuta (getUserIdFromRequest(req) y getIdProveedorSaludByUserId(actorId)), eventClass: CLASS_1_HARD_FAIL).
</task>

<task>
**Task 05-02.5 — Change password: USER_PASSWORD_CHANGED**
- En users.controller.ts método updatePassword() (POST forgot-password/:token): después de user.token = '', user.password = password, await user.save(), obtener proveedorSaludId = user.idProveedorSalud?.toString() ?? null. Llamar auditService.record(USER_PASSWORD_CHANGED, resourceType: 'USER', resourceId: user._id.toString(), payload: { userId: user._id.toString() } (sin password), proveedorSaludId, actorId: user._id.toString(), eventClass: CLASS_1_HARD_FAIL).
</task>

---

## Verification

- Registrar usuario (register) → aparece evento USER_INVITATION_SENT en lista de auditoría con payload sin password.
- Verificar cuenta (verify/:token) → aparece USER_ACTIVATED.
- PATCH estado-cuenta/:userId con cuentaActiva: false → USER_SUSPENDED; con true → USER_REACTIVATED.
- DELETE delete-user/:email → USER_DELETED con payload del usuario eliminado.
- POST forgot-password/:token con password nueva → USER_PASSWORD_CHANGED.
- Si se desactiva temporalmente la escritura de audit, las operaciones anteriores deben fallar (Clase 1).

---

## must_haves (checklist final)

- [ ] USER_INVITATION_SENT en register (tras crear y enviar email).
- [ ] USER_ACTIVATED en verifyAccount (tras activar).
- [ ] USER_SUSPENDED y USER_REACTIVATED en toggleAccountStatus según body.cuentaActiva.
- [ ] USER_DELETED en removeUserByEmail (con snapshot previo al borrado).
- [ ] USER_PASSWORD_CHANGED en updatePassword (forgot-password/:token).
- [ ] Ningún payload incluye password ni hash; payload con email/username/role donde aplique.
