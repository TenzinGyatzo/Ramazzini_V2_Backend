---
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/modules/giis-export/schema-loader.ts
  - src/modules/giis-export/giis-serializer.service.ts
  - src/modules/giis-export/validators/giis-row.validator.ts
  - src/modules/giis-export/transformers/cdt.mapper.ts
  - src/modules/giis-export/giis-export.service.ts
  - test/nom024/giis-serializer.nom024.spec.ts
  - test/nom024/giis-export-cdt.nom024.spec.ts
autonomous: true
---

# Plan 01-02 — Subfase 1B: Serializer schema-driven + export CDT (B019)

**Objetivo:** Header y orden de columnas salen exclusivamente del `docs/nom-024/giis_schemas/CDT.schema.json`. Serializer que genera primera línea (encabezado con nombres de variables) y filas de datos; mapper CDT (detección → objeto plano); validator mínimo (conteo/orden + requiredColumn); escritura de artifact TXT para CDT y actualización del batch. Test: fixture 1 detección → archivo TXT con header correcto + 1 fila, encoding y separadores según schema.

**Regla dura:** NO hardcodear listas de campos. Header, orden y conteo de columnas desde schema JSON como fuente de verdad.

---

## must_haves

- [ ] Cargar schema desde `docs/nom-024/giis_schemas/CDT.schema.json` (y luego CEX/LES desde sus archivos): encoding, delimiter, listDelimiter, subattrDelimiter, y array `fields` con `id`, `name`, `requiredColumn`.
- [ ] Serializer: dado un schema cargado y un array de objetos plano (un objeto por fila, keys = field names), generar línea de encabezado (nombres en orden del schema) y una línea por fila (valores en el mismo orden); separador = delimiter del schema; encoding Windows-1252 al escribir archivo.
- [ ] Mapper CDT: transformar 1 documento Deteccion (o DTO) + contexto (CLUES/9998) → objeto plano con las keys del schema CDT (usar schema para saber nombres; defaults/vacíos según requiredColumn).
- [ ] Validator mínimo: por fila, verificar que el número de columnas coincide con schema y que las columnas requiredColumn no estén vacías (o cumplir default); opcionalmente validar tipos (string length, numeric).
- [ ] Integración en flujo de batch: para batch en estado generating, generar TXT CDT (header + N filas), guardar en disco (path por convención, ej. exports/giis/{proveedorId}/{yearMonth}/CDT.txt), actualizar batch.artifacts con { guide: 'CDT', path, rowCount } y status completed (para el caso solo-CDT).
- [ ] Test unit: serializer con schema CDT cargado → header line equals names from schema joined by |; one row → same number of columns.
- [ ] Test integration: 1 detección fixture → mapper CDT → serializer → validator → archivo TXT existe; contenido tiene primera línea = encabezado, segunda línea con separadores correctos.
- [ ] Phase 1 NO incluye 3DES/ZIP (solo TXT plano).

---

## Tasks

<task>
**Task 2.1 — Schema loader y serializer schema-driven**
- Crear `src/modules/giis-export/schema-loader.ts`: función `loadGiisSchema(guide: 'CDT'|'CEX'|'LES')` que lee `docs/nom-024/giis_schemas/{guide}.schema.json` (path desde process.cwd() o __dirname), parsea JSON y devuelve objeto con guide, encoding, delimiter, listDelimiter, subattrDelimiter, fields (array ordenado por id).
- Crear `src/modules/giis-export/giis-serializer.service.ts`: método `serialize(schema, rows: Record<string, string|number>[])`: primera línea = fields.map(f => f.name).join(schema.delimiter); cada fila = schema.fields.map(f => row[f.name] ?? '').join(schema.delimiter). Retornar string (o Buffer en encoding windows-1252). NO hardcodear nombres de campos; todo desde schema.fields.
- Test en `test/nom024/giis-serializer.nom024.spec.ts`: load schema CDT, serialize con 0 rows → solo header line; con 1 row (objeto con keys del schema) → 2 lines; verificar número de columnas = schema.fields.length.
</task>

<task>
**Task 2.2 — Mapper CDT y validator mínimo**
- Crear o adaptar `src/modules/giis-export/transformers/cdt.mapper.ts`: entrada = Deteccion (o documento detección) + contexto { clues: string }; salida = Record<string, string|number> con una key por cada field.name del schema CDT (cargar schema en mapper). Mapear campos conocidos desde detección a nombres del schema; usar clues del contexto para campo clues; para campos sin dato usar default o vacío según requiredColumn (documentar matriz por campo si hace falta en comentario).
- Crear `src/modules/giis-export/validators/giis-row.validator.ts`: `validateRow(schema, row: string[]): { valid: boolean, errors?: string[] }` — comparar row.length === schema.fields.length; para cada índice i donde schema.fields[i].requiredColumn === true, comprobar que row[i] no sea vacío (trim). Retornar valid true solo si pasa.
- Test: mapper con fixture detección + clues 9998 → objeto plano con al menos clues=9998 y número de keys = 92 (CDT); validator con fila de 92 columnas y required presentes → valid true; fila con una required vacía → valid false.
</task>

<task>
**Task 2.3 — Integración batch + escritura artifact CDT**
- En `giis-export.service.ts` (o nuevo método en GiisBatchService): dado batchId y proveedorId/yearMonth, cargar batch; cambiar status a generating; cargar detecciones del periodo (y proveedor) desde BD; para cada una, mapper CDT → acumular rows; serializar con schema CDT (header + rows); validar cada fila (validator); escribir archivo en disco (path ej. `exports/giis/{proveedorId}/{yearMonth}/CDT.txt` con encoding windows-1252); actualizar batch.artifacts.push({ guide: 'CDT', path, rowCount }); status = completed; completedAt = now.
- Asegurar que el directorio de salida exista (mkdir -p).
- Test en `test/nom024/giis-export-cdt.nom024.spec.ts`: crear batch (1A), ejecutar generación CDT con 1 detección fixture, leer batch de nuevo → status completed, artifacts.length 1, artifact.guide === 'CDT'; leer archivo del path → primera línea = header con nombres del schema, segunda línea con 92 columnas separadas por |.
</task>

---

## Verification

- `npm run test:nom024` pasa para giis-serializer y giis-export-cdt.
- Ninguna lista de campos hardcodeada: header y orden solo desde CDT.schema.json.
- Archivo TXT generado con encoding Windows-1252 y delimitador `|`.
